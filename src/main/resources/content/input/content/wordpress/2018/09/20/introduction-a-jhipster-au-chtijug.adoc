:jbake-type: post
:jbake-status: published
:jbake-title: Introduction Ã  JHipster au chtijug
:jbake-tags: chtijug,java,javascript,open-source,spring,_mois_sept.,_annÃ©e_2018
:jbake-date: 2018-09-20
:jbake-depth: ../../../../
:jbake-uri: wordpress/2018/09/20/introduction-a-jhipster-au-chtijug.adoc
:jbake-excerpt: 
:jbake-source: https://riduidel.wordpress.com/2018/09/20/introduction-a-jhipster-au-chtijug/
:jbake-style: wordpress

++++
<p>
<div class='twitter'>
<br/>
<span class="twitter_status">
</p>
<p>
<span class="author">
</p>
<p>
<a href="http://twitter.com/ippontech" class="screenName"><img src="http://pbs.twimg.com/profile_images/1037335349897375745/0SSQ5A2f_mini.jpg" alt="profile of Cabinet de conseil - Discovery to Delivery
<br/>
La Matinale ğŸ‘‰ https://t.co/cMCL39P4jA
<br/>
#Design #Digital #Data #Cloud #Fullstack #Marketing #Agilite"/>ippontech</a>
<br/>
<span class="name">Ippon Technologies</span>
</p>
<p>
</span>
</p>
<p>
<a href="https://twitter.com/ippontech/status/1Â 042Â 818Â 412Â 580Â 356Â 096" class="date">20 sept. 2018 Ã  18:50:58</a>
</p>
<p>
<span class="content">
</p>
<p>
<span class="text">Salle comble Ã  #Lille pour le @chtijug avec @juliendubois pour prÃ©senter @java_hipster #JHipster #OpenSource https://t.co/JifZMnJ51b</span>
</p>
<p>
<span class="medias">
<br/>
<span class="media media-photo">
<br/>
<img src="http://pbs.twimg.com/media/DnjVaO_WwAEAV8-.jpg" alt="1Â 042Â 817Â 960Â 413Â 413Â 377"/>
<br/>
</span>
<br/>
<span class="media media-photo">
<br/>
<img src="http://pbs.twimg.com/media/DnjVd17WwAAhUUq.jpg" alt="1Â 042Â 818Â 022Â 405Â 226Â 496"/>
<br/>
</span>
<br/>
<span class="media media-photo">
<br/>
<img src="http://pbs.twimg.com/media/DnjVoZ7XcAEKpRY.jpg" alt="1Â 042Â 818Â 203Â 867Â 639Â 809"/>
<br/>
</span>
<br/>
</span>
</p>
<p>
</span>
</p>
<p>
<span class="twitter_status_end"/>
<br/>
</span>
<br/>
</div>
<br/>
<div id="preamble">
<br/>
<div class="sectionbody">
<br/>
<div class="paragraph data-line-3">
</p>
<p>
Julien Dubois vient donc nous prÃ©senter le framework quâ€™il a crÃ©Ã© â€¦â€‹ <a href="https://www.jhipster.tech/">JHipster</a>. <a href="https://spring.io/projects/spring-framework">Spring</a>, câ€™est un gros paquet dâ€™ingrÃ©dients. <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, câ€™est la mÃªme chose bien packagÃ©e. Et JHipster, câ€™est ce package encore dÃ©corÃ©. Autrement dit, câ€™est un gÃ©nÃ©rateur dâ€™application full stack avec Spring Boot en back-end, Angular et React en front-end (mais Vuejs arrive bientÃ´t), et prÃ©configurÃ© pour Ãªtre facilement dÃ©ployable.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-9">
</p>
<p>
A noter que JHipster est 100% open-source sous licence Apache (la meilleure pour le commerce, quand mÃªme).
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-11">
</p>
<p>
Câ€™est un projet qui rÃ©ussit : 22 dÃ©veloppeurs dans la core team, 500 contributeurs, des confÃ©rences, des Ã©toiles GitHub, â€¦â€‹
</p>
<p>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div class="sect1 data-line-13">
<br/>
<h2 id="truepourquoi">Pourquoi ?</h2>
<br/>
<div class="sectionbody">
<br/>
<div class="paragraph data-line-15">
</p>
<p>
JHipster fait gagner du temps au dÃ©marrage (avec des Ã©tudes qui montrent un gain de 6 semaines au dÃ©marrage), au build (comme le projet est trÃ¨s utilisÃ©, le code gÃ©nÃ©rÃ© est stable et fiable), et au run (le monitoring est dÃ©ja prÃ©vu).
</p>
<p>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div class="sect1 data-line-17">
<br/>
<h2 id="truestack_technique">Stack technique</h2>
<br/>
<div class="sectionbody">
<br/>
<div class="sect2 data-line-19">
<br/>
<h3 id="truefront_end">front-end</h3>
<br/>
<div class="paragraph data-line-20">
</p>
<p>
JHipster propose une stack complÃ¨te, avec des front bien connus. Mais attention : tous les widgets de lâ€™univers ne sont pas supportÃ©s. Parce que Ã§a fait trop de code dâ€™une part, mais aussi parce que ce sont des technologies qui Ã©voluent trÃ¨s rapidement.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect2 data-line-23">
<br/>
<h3 id="trueback_end">back-end</h3>
<br/>
<div class="paragraph data-line-24">
</p>
<p>
Evidement, le back est intÃ©gralement Spring .. il y a toutefois quelques choix qui sont faits (par exemple, JHipster utilise toujours <a href="https://metrics.dropwizard.io/">DropWizard Metrics</a>, parce que la communautÃ© nâ€™est pas fan des nouvelles <a href="https://micrometer.io/">mÃ©triques Spring</a>).
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect2 data-line-26">
<br/>
<h3 id="trueoutillage">Outillage</h3>
<br/>
<div class="paragraph data-line-27">
</p>
<p>
Les tests de base sont dÃ©ja prÃ©parÃ©s. En revanche, les tests Gatling ou <a href="http://www.protractortest.org/#/">Protactor</a> sont optionnels â€¦â€‹ mais ajoutables facilement.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-30">
</p>
<p>
Par ailleurs, JHipster suppose que vous utilisez Docker â€¦â€‹ parce que câ€™est pratique et câ€™est quasiment un standard. Cependant, si vous voulez utilisez MySQL ou Elastic, il faudra en passer par lÃ .
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-33">
</p>
<p>
Le dÃ©ploiement est prÃ©parÃ© pour heroku (beaucoup utilisÃ© parce que gratuit), Kubernetes, OpenShift, â€¦â€‹
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect2 data-line-35">
<br/>
<h3 id="truearchitecture">Architecture</h3>
<br/>
<div class="paragraph data-line-36">
</p>
<p>
JHipster permet de gÃ©nÃ©rer une architecture microservice, en crÃ©ant un module par service de back-end et un ou plusieurs modules de front-end.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-38">
</p>
<p>
Il peut aussi utiliser une service registry (celle de <a href="https://github.com/Netflix/eureka">Netflix</a> ou de <a href="https://www.consul.io/">Consul</a> sont intÃ©grÃ©es) ou une API gateway.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-40">
</p>
<p>
Lâ€™objectif Ã©tant dâ€™avoir la mÃªme expÃ©rience dÃ©veloppeur que pour un monolithe. Ca paraÃ®t sÃ©duisant sur le papier â€¦â€‹
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-42">
</p>
<p>
Et enfin, il est possible de crÃ©er des microservices rÃ©actifs utilisant Spring Boot 2 â€¦â€‹ et les composants Spring rÃ©actifs, Ã©videment.
</p>
<p>
Toutefois, sur le sujet des microservices, je me dois d'avouer qu'Ã  mon ens on est dÃ©ja lÃ  dans une dÃ©marche dÃ©passÃ©e : aujourd'hui, le marchÃ© semble converger vers les service meshs (<a href="https://istio.io/">Istio</a>, <a href="https://www.consul.io/intro/getting-started/connect.html">Consul Connect</a>, ou <a href="https://conduit.io/">Conduit</a>). Et franchement, continuer Ã  implÃ©menter la couche de service dans l'application ... c'est lourd, c'est peu efficace, et Ã§a rajoute de la complexitÃ© au mauvais endroit.
</p>
<p>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div class="sect1 data-line-44">
<br/>
<h2 id="trued_mo">DÃ©mo</h2>
<br/>
<div class="sectionbody">
<br/>
<div class="paragraph data-line-46">
</p>
<p>
Et câ€™est parti pour la dÃ©mo Ã  la cool !
</p>
<p>
</div>
<br/>
<div class="sect2 data-line-48">
<br/>
<h3 id="trueinstallation">Installation</h3>
<br/>
<div class="paragraph data-line-49">
</p>
<p>
On peut <a href="https://www.jhipster.tech/installation/">installer JHipster</a> avec npm (wat ?), Homebrew, Chocolatey, â€¦â€‹
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-51">
</p>
<p>
Mais on peut aussi, comme pour <a href="https://start.spring.io/">Spring boot</a> (ou <a href="http://wisdom-framework.org/download">Wisdom Framework</a>), crÃ©er le projet depuis le site web de JHipster. Donc on se connecte, et grÃ¢ce Ã  lâ€™intÃ©gration GitHub/GitLab, le projet est directement crÃ©Ã© dans le gestionnaire de source (comme avec <a href="https://jenkins-x.io/commands/jx_create_jhipster/">Jenkins-X</a>).
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-54">
</p>
<p>
Les options de crÃ©ation de projet sont assez nombreuses (monitoring, authentification, base de donnÃ©es, â€¦â€‹). Câ€™est lâ€™un des intÃ©rÃªts de JHipster : gÃ©rer des sujets auxquels Spring Boot ne sâ€™intÃ©resse pas. Lâ€™impact Ã©vident, câ€™est que le dÃ©marrage est plus lent que Spring Boot â€¦â€‹ qui nâ€™est dÃ©ja pas fameux sur ce sujet. Parce que JHipster dÃ©marre un EHCache, un hibernate, â€¦â€‹
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-59">
</p>
<p>
En dehors de Ã§a, JHipster peut gÃ©rer lâ€™accÃ¨s Ã  ElasticSearch, ou Kafka. Dans le cas dâ€™Elastic, Ã§a a un impact sur le front et sur le back (parce que JHipster gÃ©nÃ¨re les outils dâ€™accÃ¨s, et lâ€™interface de recherche). Qui plus est, le <code>docker-compose.yaml</code> sera Ã©galement gÃ©nÃ©rÃ© pour le dÃ©veloppement avec Elastic.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-63">
</p>
<p>
Et lorsquâ€™on clique sur "generate on GitHub", le projet est automatiquement gÃ©nÃ©rÃ© avec les bons <code>*ignore</code>.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect2 data-line-65">
<br/>
<h3 id="trueouverture_du_projet">Ouverture du projet</h3>
<br/>
<div class="paragraph data-line-67">
</p>
<p>
Donc le projet a Ã©tÃ© gÃ©nÃ©rÃ© avec un <code>pom.xml</code> pour maven, et un <code>package.xml</code> pour gÃ©nÃ©rer le front-end. Et au lancement, on dÃ©marre node et maven, le front et le back se lance (pour le front, aprÃ¨s avoir copiÃ© 1/2 Go de dÃ©pendances Node). Ca me trouble un chouaÃ¯, parce que je ne vois pas pourquoi il faut lancer deux outils de build diffÃ©rents ... pour produire les deux morceaux de la mÃªme application.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-70">
</p>
<p>
Spring-boot et webpack sont configurÃ©s pour faire du rechargement Ã  chaud, ce qui fait quâ€™il nâ€™y a pas besoin de relancer les outils de build. C'est quelque chose qu'on a aussi dans Spring-Boot, dans Wisdom Framework - mais bien mieux (dÃ©solÃ©, mais c'est vrai) ou mÃªme en Rust avec <a href="https://github.com/passcod/cargo-watch">cargo watch</a>.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-72">
</p>
<p>
Lâ€™application est gÃ©nÃ©rÃ©e avec de lâ€™authentification, ce qui est cool, mais aussi tout un tas d'Ã©crans dâ€™administration. On peut voir les mÃ©triques, les niveaux de logs (et les changer), â€¦â€‹ Câ€™est franchement pratique.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-76">
</p>
<p>
Il y a Ã©galement un <a href="https://www.browsersync.io/">browser-sync</a>, qui permet dâ€™avoir plusieurs clients synchronisÃ©s (câ€™est typiquement pratique pour le dÃ©veloppement web avec des Ã©crans rÃ©actifs).
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-78">
</p>
<p>
Et encore la configuration Docker â€¦â€‹ avec le fichier de configuration permettant lâ€™accÃ¨s Ã  la base de donnÃ©es.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-80">
</p>
<p>
Et beaucoup de configuration Java, pour optimiser les performances de Jackson, par exemple, ou pour corriger des implÃ©mentations pas optimales, ou pour lier le front-end et le back-end. Une librairie Ã©quivalente existe Ã©videment cÃ´tÃ© Javascript, encore une fois pour faciliter la vie du dÃ©veloppeur.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-83">
</p>
<p>
Et enfin les bases dâ€™une application : un utilisateur, ses droits, les repository Spring Data, les contrÃ´leurs web permettant dâ€™y accÃ©der, et mÃªme les messages internationalisÃ©s.
</p>
<p>
</div>
<br/>
<div class="sect3 data-line-85">
<br/>
<h4 id="trueecrire_du_code">Ecrire du code</h4>
<br/>
<div class="paragraph data-line-86">
</p>
<p>
JHipster fournit des sous-gÃ©nÃ©rateurs. Donc pour crÃ©er une nouvelle entitÃ©, il suffit de taper <code>jhipster entity Foo</code> par exemple.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect3 data-line-89">
<br/>
<h4 id="truejhipster_studio"><a href="https://start.jhipster.tech/jdl-studio/">JHipster Studio</a></h4>
<br/>
<div class="paragraph data-line-90">
</p>
<p>
Avec ce studio, on peut dÃ©crire facilement des entitÃ©s dans un DSL â€¦â€‹ qui ressemble <strong>furieusement</strong> Ã  un descripteur UML. Ce studio est utilisable dans une interface web, ou via un plugin Eclipse (cool). Et le modÃ¨le peut Ãªtre appliquÃ© sur une application prÃ©existante. Lâ€™avantage du studio web, câ€™est quâ€™il gÃ©nÃ¨re une pull request automatiquement, ce qui est cool. Ce qui lâ€™est moins, câ€™est que <strong>110 fichiers</strong> ont Ã©tÃ© gÃ©nÃ©rÃ©s pour 4 entitÃ©s. 110 fichiers ! Câ€™est pas un peu beaucoup ?
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-98">
</p>
<p>
Si, mais il y a quand mÃªme un front-end, un back-end, et toute la connexion entre les deux. Câ€™est malgrÃ© tout impressionnant.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-101">
</p>
<p>
MÃªme si Ã§a ne marche pas.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect3 data-line-103">
<br/>
<h4 id="truem_ta_mod_le">MÃ©ta-modÃ¨le</h4>
<br/>
<div class="paragraph data-line-104">
</p>
<p>
Julien rencontre Ã  ce moment-lÃ  une difficultÃ© qui lâ€™oblige Ã  tout rÃ©gÃ©nÃ©rer â€¦â€‹. y compris le code Java. Pour Ã§a, JHipster maintient un mÃ©ta-modÃ¨le avec lequel il gÃ©nÃ¨re le code Java et le code Javascript.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-107">
</p>
<p>
Ca ne marche pas mieux aprÃ¨s, mais câ€™est nÃ©anmoins impressionnant.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-109">
</p>
<p>
Surtout quand je me rends compte quâ€™en fait, JHipster est un outil de gÃ©nÃ©ration Ã  base de modÃ¨le UML. ModÃ¨les qui sont bien cachÃ©s, câ€™est vrai, mais qui se rÃ©vÃ¨lent bien pratiques.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect3 data-line-112">
<br/>
<h4 id="truediff_rence_dev_prod">DiffÃ©rence dev-prod</h4>
<br/>
<div class="paragraph data-line-113">
</p>
<p>
Pour aller plus loin, Julien nous montre que lâ€™application, quand elle se lance en mode production, dÃ©marre plus lentement, parce que les comportements sont diffÃ©rents :
</p>
<p>
</div>
<br/>
<div class="ulist data-line-115">
<br/>
<ul>
<br/>
<li>Le code Angular est minifiÃ©</li>
<br/>
<li>Les stratÃ©gies de cache cÃ´tÃ© serveur sont plus aggressives</li>
<br/>
<li>Les descripteurs Swagger peuvent (ou pas) Ãªtre gÃ©nÃ©rÃ©s</li>
<br/>
</ul>
<br/>
</div>
<br/>
</div>
<br/>
<div class="sect3 data-line-119">
<br/>
<h4 id="truetests">Tests</h4>
<br/>
<div class="paragraph data-line-120">
</p>
<p>
Sur cette application, 160 tests sont gÃ©nÃ©rÃ©s pour le back et 152 pour le front. Et câ€™est lÃ  quâ€™on voit tout ce que cache ce gÃ©nÃ©rateur â€¦â€‹. Il y a 5 entitÃ©s. Et Ã§a mÃ©rite 300 tests ? Jâ€™imagine que oui, bien sÃ»r.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect3 data-line-123">
<br/>
<h4 id="truemise_jour">Mise Ã  jour</h4>
<br/>
<div class="paragraph data-line-124">
</p>
<p>
La ligne de commande contient une commande <code>jhipster update</code> qui permet de mettre Ã  jour le projet par rapport Ã  une version suivante, via un merge git. Câ€™est conceptuellement vraiment, mais alors vraiment balaize. Et Ã§a facilite Ã©videment Ã©normÃ©ment les mises Ã  jour de version.
</p>
<p>
</div>
<br/>
</div>
<br/>
<div class="sect3 data-line-128">
<br/>
<h4 id="truemise_en_prod">Mise en prod</h4>
<br/>
<div class="paragraph data-line-129">
</p>
<p>
Pour finir, il existe des sous-gÃ©nÃ©rateurs permettant de dÃ©ployer lâ€™application dans les infrastructures de prod. Julien prend donc lâ€™exemple de <code>jhipster heroku</code> â€¦â€‹ qui dÃ©ploie chez heroku (dingue).
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-132">
</p>
<p>
Et les diffÃ©rents cloudeurs ont produit des optimisations spÃ©cifiques. Par exemple, Google App Engine dÃ©ploie le front-end sur son CDN, et les requÃªtes qui arrivent sur votre "serveur" sont celles qui concernent le back uniquement.
</p>
<p>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
</div>
<br/>
<div class="sect1 data-line-135">
<br/>
<h2 id="trueconclusion">Conclusion</h2>
<br/>
<div class="sectionbody">
<br/>
<div class="paragraph data-line-136">
</p>
<p>
Julien vend particuliÃ¨rement bien son outil. Et honnÃªtement, il a raison : JHipster est bien fichu, et fournit un certain nombre de services spectaculairement pratiques. Lâ€™un des plus importants, mais des moins visibles, est la mise en place dâ€™une approche MDA pragmatique et efficace. En revanche, ayant utilisÃ© pendant un certain temps Wisdom Framework, je trouve le choix de se baser sur Spring pour construire un gÃ©nÃ©rateur dâ€™applications magnifiÃ© me paraÃ®t â€¦â€‹ discutable : je trouve la quantitÃ© d'Ã©lÃ©ments gÃ©nÃ©rÃ©s hallucinante, pour un rÃ©sultat qui est raisonnablement joli, mais pas non plus fascinant (typiquement, les dÃ©mos de Julien nâ€™ont montrÃ© que Twitter Bootstrap (aucun des Ã©lÃ©ments visuels ne nÃ©cessitait Angular ou React). Malheureusement, je pense quâ€™il est de moins en moins pertinent de "gÃ¢cher" du CPU en fournissant un Ã©chafaudage de projet - aussi poussÃ© soit-il. En effet, on voit maintenant Ã©merger des approches - type "Function as a service" - qui interdisent totalement ce genre dâ€™outillage.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-143">
</p>
<p>
Alors certes Ã§a nâ€™est pas la cible.
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-145">
</p>
<p>
Mais quand mÃªme. Quelle application dÃ©ployer avec JHipster ? Un outil "lÃ©ger" non critique ? Quel genre dâ€™outil peut encore avoir besoin de la "puissance" de la JVM, en Ã©tant toutefois assez simple pour Ãªtre dÃ©veloppable en PHP ?
</p>
<p>
</div>
<br/>
<div class="paragraph data-line-148">
</p>
<p>
Autrement dit, simplifier Spring, pour moi, est une "solution" qui ne me paraÃ®t pas, malgrÃ© tous les exemples de mise en oeuvre prÃ©sentÃ©s - avec brio, je dois dire - par Julien, Ãªtre applicable Ã  un cas "utile". Quelque part, câ€™est avant tout un outil de commodisation du dÃ©veloppement, applicable dans les cas oÃ¹ le logiciel ne doit pas Ãªtre un obstacle Ã  une tÃ¢che, mais ne doit pas non plus Ãªtre un facteur de succÃ¨s.
</p>
<p>
</div>
<br/>
</div>
<br/>
</div>
</p>
++++